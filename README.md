# Язык программирования 

## Установка

```
git clone https://github.com/d3clane/ProgrammingLanguage.git
cd Src
make buildDirs && make
```

## Описание

Основная цель - написать свой собственный язык программирования, который переводится в ассемблер для моей [эмуляции процессора](https://github.com/d3clane/Processor-Emulator), а затем исполняется на нем. 

Проект состоит из четырех частей:
1. [FrontEnd](#FrontEnd)
2. [MiddleEnd](#MiddleEnd)
3. [BackEnd](#BackEnd)
4. [BackFrontEnd](#BackFrontEnd)

Фактически, это четыре независимых программы:

1. FrontEnd переводит написанный на моем языке код в [AST](#AST) - abstract syntax tree.
2. MiddleEnd упрощает полученное дерево (самые минимальные оптимизации).
3. BackEnd переводит AST в ассемблер для моего процессора. 
4. BackFrontEnd - забавный бонус, который умеет переводить из AST в исходный код на моем языке.

Почему frontend, middleend, backend - это три программы, а не одна сплошная? 

Представим ситуацию, что мне нужно написать frontend для $n$ различных языков программирования, а затем перевести их в $m$ различных ассемблеров. Если принять стандарт AST и переводить всегда в один и тот же вид, то получится, что мне надо написать всего $n$ frontend-ов и $m$ backend-ов, тем самым получив $nm$ различных вариантов компиляции. 

Если же писать сплошные программы, то нужно написать $nm$ таких программ. Очевидно, что первое предпочтительнее, даже несмотря на то, что появятся лишние издержки на запись и чтение дерева из файла(временного хранилища между программами).

## AST 

AST(abstract syntax tree) - это представление какого-то исходного кода в виде подвешенного дерева. Каждая из вершин, у которых есть дети, описывает какую-то операцию(например, while или add). Листья же дерева описывают операнды (числа, переменные). 

Порядок действий, в котором надо выполнять какие-то действия определяется структурой дерева. Например, даже если в исходном коде у арифметических выражений были скобочки, которые определяли порядок выполнения действий, в AST их уже нет, а порядок определяется расположением операций друг относительно друга. Рассмотрим на примере:

Выражение int value = $(2 + 3) \cdot (4 + 5)$ выглядит так:

![add_mul](https://github.com/d3clane/Compiler/blob/main/ReadmeAssets/imgs/add_mul.png)

А выражение int value = $2 + 3 \cdot (4 + 5)$ вот так:

![mul_add](https://github.com/d3clane/Compiler/blob/main/ReadmeAssets/imgs/mul_add.png)

При спуске по дереву сначала полностью рассчитывается выражение в левом поддереве, потом в правом, а затем применяется операция в вершине к полученным результатам. Фактически, на первом примере сначала посчитается сумма $2 + 3$, затем $4 + 5$, а потом их произведение. Во втором же случае посчитается $4 + 5$, затем $3 \cdot (4 + 5)$, а затем $2 + 3 \cdot (4 + 5)$. 

## FrontEnd

Frontend переводит написанный на моем языке код в AST. Здесь важно понять, как анализировать исходный код. Фактически, прежде чем начать писать язык, надо придумать синтаксис для него. Для этого зададим грамматику, по которой затем будем делать разбор языка с помощью алгоритма рекурсивного спуска.

FrontEnd также разделен на две части - лексический анализ и синтаксический анализ. Лексический анализ нужен, чтобы разбить исходный код на токены - единицы грамматики, которые затем легче анализировать. На этом этапе можно избавиться от комментариев, пробелов, отступов и тому подобных вещей в коде - то, что не влияет на результат исполнения.

Синтаксический анализ - часть, в которой непосредственно массив из лексем(токенов) превращается в AST. В моем случае это происходит с помощью рекурсивного спуска.

### Синтаксис

Грамматика:

```
Grammar          ::= FUNC+ '\0'
FUNC             ::= FUNC_DEF
FUNC_DEF         ::= TYPE VAR FUNC_VARS_DEF '57' OP '{'
FUNC_VAR_DEF     ::= {TYPE VAR}*
OP               ::= { IF | WHILE | '57' OP+ '{' | {VAR_DEF | PRINT | ASSIGN | RET} '57' }
IF               ::= '57?' OR '57' OP
WHILE            ::= '57!' OR '57' OP
RET              ::= OR
VAR_DEF          ::= TYPE VAR '==' OR
PRINT            ::= '{' { ARG | CONST_STRING }
READ             ::= '{'
ASSIGN           ::= VAR '==' OR
OR               ::= AND {and AND}*
AND              ::= CMP {or CMP}*
CMP              ::= ADD_SUB {[<, <=, >, >=, =, !=] ADD_SUB}*
ADD_SUB          ::= MUL_DIV {[+, -] MUL_DIV}*
MUL_DIV          ::= POW {[*, /] POW}*
POW              ::= FUNC_CALL {['^'] FUNC_CALL}*
FUNC_CALL        ::= IN_BUILT_FUNCS | MADE_FUNC_CALL | EXPR
IN_BUILT_FUNCS   ::= [sin/cos/tan/cot/sqrt] OR '57'  | READ
MADE_FUNC_CALL   ::= VAR '{' FUNC_VARS_CALL '57' 
FUNC_VARS_CALL   ::= {OR}*
EXPR             ::= '(' OR ')' | ARG
ARG              ::= NUM | GET_VAR
NUM              ::= ['0'-'9']+
VAR              ::= ['a'-'z' 'A'-'Z' '_']+ ['a'-'z' 'A'-'Z' '_' '0'-'9']*
CONST_STRING     ::= '"' [ANY_ASCII_CHAR]+ '"'
TYPE             ::= 575757
```

Краткое справка по обозначениям:

- [...] - означает множество различный элементов в каком-то диапазоне. 
- { A | B | C | ...} - означает, что на данном этапе должно выполняться одно из грамматических правил в этом множестве. 
- A+ - A повторяется один или более раз
- A* - A повторяется ноль или более раз
- 'A' - это значит, что должна встретиться непосредственно буква A.

Основные моменты, которые отличают мой язык программирования от си:

- В языке нет такого понятия, как запятая. Когда хочется перечислить аргументы или параметры функции, то достаточно просто оставить пустой пропуск между ними. 
- Какие-то скобки опущены. Например, при перечислении параметров функции в ее определении нет скобок, окружающих параметры. На примере си вместо `int func(int val1, int val2)` будет `int func int val1 int val2`. Также опущены открывающие скобки в конструкциях if / while.
- Если какая-то операция в языке возвращает результат, но при этом он никуда не присваивается, то считается, что это операция возврата из функции. На примере си строчки кода вида `2 + 3;` `FuncCall();` по стандарту считаются строчками вида `return 2 + 3;` или `return FuncCall()`. Чтобы этого избежать надо присваивать полученные на выходе значения: `int val = 2 + 3` или `int tmp = FuncCall()`. 
- Все операции перепутаны: `+` это `-`, `*` это `/`, `<` это `>`, `=` это `==`.

Чтобы написать комментарий к коду надо начать с символа `@`. 

Перейдем к описанию обработки грамматики.

### Лексический анализ 

Здесь ничего сложного. Просто проходясь по исходному коду, я превращаю элементарные языковые конструкции в токены. Например, `575757` превратится в токен `TYPE_INT`, а `58` в число 58. В языке существуют неоднозначные конструкции по типу `57` которые в разных контекстах могут означать разное. Например, иногда это может быть аналог `;`, а иногда аналог `}` в конструкциях if / while. В этом случае такие конструкции превращаются в токены вида `TOKEN_57`. 

На этом этапе также удаляются все комментарии, лишние пробелы и отступы, которые не влияют на результат исполнения.

### Рекурсивный спуск

После построения грамматики в рекурсивном спуске нет никакой сложности. Все что надо - переписать действия, которые написаны в грамматике в виде функций. Проходя по токенам создавать вершины, если грамматическое правило верно или подвязывать их. Если ни одно из грамматических правил не подходит - выдать синтаксическую ошибку.

Пример AST, которое строится по исходному коду [программы для нахождения факториала числа](examples/factorial.txt):

![factorial](https://github.com/d3clane/Compiler/blob/main/ReadmeAssets/imgs/factorial.png)

Операции отмечены зеленым цветом, имена (переменных / функций / строковые литералы) голубым, числа темно-синим. 

## MiddleEnd

MiddleEnd на данный момент поддерживает очень сильно ограниченное количество оптимизаций, а конкретно всего две:

1. Свертка констант. Арифметические выражения, в которых не участвуют переменные, сворачиваются в одну константу. То есть, например, $(5 \cdot 6) + 3 / 1$ свернется в одну вершину со значением $33$.
2. Удаление нейтральных вершин. Например, домножение любого выражения на ноль сворачивается в ноль. Или, домножение на единицу сворачивается просто в это же выражение, но единица удаляется.

Подобные оптимизации происходят до тех пор, пока они все еще могут происходить. Если после очередного цикла оптимизаций дерево не изменилось, middleEnd завершает свою работу.

## BackEnd

На данный момент происходит дамп в ассемблер для моей эмуляции процессора. Спускаясь по дереву для каждой вершины рекурсивно строим ее и детей. На выходе получается ассемблерный файл, который с помощью ассемблера моего стекового процессора переводится в бинарный код для него, а затем исполняется на нем. 

В конце уже следующего семестра backend надо было переписать - он должен был создавать сразу исполняемые elf файл под архитектуру x86_64. Этот проект можно глянуть по ссылке: https://github.com/d3clane/Compiler/tree/main. 

## BackFrontEnd

Это программа, которая по виду AST умеет строить исходный код. Зачем вообще это может быть нужно? В нашем случае у меня и у [metaironia](https://github.com/metaironia) единый стандарт представления AST, хоть у нас и разные языки программирования. Получается, что можно переводить код из одного языка в другой - сначала из языка A в AST, а затем из AST в язык B. Это довольно бесполезно, но забавно.




